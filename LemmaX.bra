{LemmaX.bra

For each input word, predict the possible lemma(s) and for each predicted lemma
predict also the classes (e.g. Part of Speech tags) that may apply.

The program first tests whether the input word is in the dictionary. If that is
the case, it presents the classes that are found in the dictionary.

If the word is not found in the dictionary, and if the word contains upper case
letters, then a new attempt is made with the lowercased version of the input
word.

If the word still is not found in the dictionary, then the rules are applied.
Again, special action is taken if the word contains uppercase letters:

If the rules generate more lemmas for the lowercased version of the input word
than for the original word, then the the result from lowercasing is used.

Conversely, if the rules generate more lemmas for the original version of the
input word than for the lowercased vesrion of the word, then the the result
for the original word is used.

The result from lowercasing is also used if the number of lemmas is the same
in both cases, but the total number of classes is less for the lowercased word.

So the rules are applied to maximise the number of lemmas, but to minimize the
total number of classes if the number of lemmas is the same for the original
and for the lowercased input word.

--- Input and Output

The input should be tokenised. Tokens may be separated by new lines and by
spaces.

The output is rather complex. For each word, all predicted lemmas are shown,
and for each lemma, all predicted classes. If an input word is found in the
dictionary, both the results according to the dictionary and those according
to the lemmatisation rules are shown.

Results from the dictionary are on a line that starts with Dict=
Results generated by rules are on a line that starts with Rule=

After the = follows the word, and then a tabulor character, followed by the
lemmas and their classes.

Each lemma is immediately followed by a : and then a list of classes, separated
by spaces. Between the last class of a lemma and the next lemma is a | 
surrounded by spaces.

--- Running

The program can be run in batch mode and interactively.

To run the program in batch mode, write

    bracmat get$\"Lemmax.bra\" <tokenised_input_file>

in Windows, and 

    bracmat "get$\"Lemmax.bra\"" <tokenised_input_file>

in Linux-like environments.

To run the program interactively, start bracmat without parameters:

    bracmat

Then, after the {?} prompt, write

    {?} get$"LemmaX.bra"

When the linguistic resources are loaded, the program says:

    Type word and press ENTER. To stop, just press ENTER.

Type words one by one. The program exits when you press ENTER on an empty line.
You can reload and re-run the program by typing

    !r

This command reads the progam and then runs and saves the program, so the last
changes you made to this file become nicely indented. In other words: if you
change the code, do not invest time in indention of the code. This is not
Python.

--- Resources

The program needs, apart from the input words, also lemmatization rules
(flexrules) and an index that assigns a set of classes to each lemmatization
rule.

If the index does not exist yet, it is built from a list of full form - lemma
data with additional class data for each full form - lemma pair. When building
this list, the program lemmatises each full form. That produces a list of one
or more lemmas. Then the program inspects the list to find the matching lemma.
(If a matching lemma is not found, then a message is added to the ERROR file.)
The ID of the rule that produced the matching lemma is paired with the class
data and remembered in the index. Finally the index is saved to a file.

This Bracmat script uses another Bracmat script, "lemmatize.bra", which must
be in the same location.

You need to install Bracmat (a programming language specialised in pattern
matching) to run this script. See

https://github.com/BartJongejan/Bracmat

===============================================================================
Comments about the code
-------------------------------------------------------------------------------
Flexrules: the path (relative or full) to the file that contains lemmatization
rules in Bracmat format. The rules should be trained WITHOUT using Part Of
Speech tags. You can create Bracmat-formatted rules as follows:

prompt> affixtrain -n FB00 -i MyTrainingdata
prompt> affixtrain -b 0/flexrules.MyTrainingdata_XC

The first command creates the flexrules in binary format, for use by CSTlemma.

The second command reads the binary flexrules and creates the files 
    0/flexrules.MyTrainingdata_XC.pretty.bra
and 
    0/flexrules.MyTrainingdata_XC.pretty.txt
You only need the first of these two files.
-------------------------------------------------------------------------------
WordLemmaPosData-file-name: the path (relative or full) to a TAB separated file
that has a column with words, a column with the lemmas of those words, and a
column with PoS tags. There may be more columns, but those will be ignored.
This can be the same file with which the flex rules were trained. (In which
case you only should have used the columns with words and with lemmas.)
-------------------------------------------------------------------------------
WordLemmaPosData-layout: This is a pattern that tells the program how a line in
the file described above is built up. The pattern must contain the pattern
variables ?word ?lemma and ?class. Write \t for a tab, and write ? for matching
anything. A ? that is the last pattern component matches everything up to the
end of the line, also any tab characters. To skip a single column, write 
    ? \t 	
Other separators than tabs can be used, e.g. semicolons, single spaces or
vertical bars. Write these characters between quotes, otherwise they are
interpreted in a way you do not want.
-------------------------------------------------------------------------------
}

LemmaX=
  ( (Flexrules="0/flexrules.short_XC.pretty.bra")
    (WordLemmaPosData-file-name=short)
    (WordLemmaPosData-layout=?word \t ?lemma \t ?class \t ?)
  )
  ( doit
  =     createIndexFile denum lemmatise theTree
      , CLS ERROR H Index IndexFile
      , R RES TheFlexRules WLCfile WordLemmaPosData
      , cls k nr nrs plinepat
      , t0 t1 word wrd wlcs
    .   !arg:(?TheFlexRules.?WordLemmaPosData.?plinepat)
      & ( denum
        =   b
          .   !arg:#%*?arg&!arg
            | !arg:(?b.?arg)&(!b.denum$!arg)
            |   !arg:?arg_?b
              & (denum$!arg)_(denum$!b)
            | !arg
        )
      & ( createIndexFile
        =     H word LmCls AllLmCls results ress lm
            , nrs A Z cls nr nnr CLS ERROR IndexFile
            , createWLCfile WLCfile WordLemmaPosData plinepat
          .   !arg:(?WordLemmaPosData.?plinepat.?IndexFile.?WLCfile)
            & ( createWLCfile
              =   WLC WLP WordLemmaPosData linepat
                .     !arg:(?WordLemmaPosData.(=?linepat))
                    & new$hash:?WLC
                    & get$(!WordLemmaPosData,STR,TXT):?WLP
                    & !( 
                       '   vap
                         $ ( ( 
                             =   word lemma class
                               .     @(!arg:$linepat)
                                   & ( @(!word:? " " ?)
                                     |   (WLC..insert)
                                       $ (!word.!lemma.!class)
                                     )
                                   & 
                                 | 
                             )
                           . $WLP
                           . \n
                           )
                       )
                    & :?wlcs
                    &   (WLC..forall)
                      $ ( 
                        =   wrd r1 r2 A L,C1 M C2 Z
                          .   !arg:(?wrd.?r1) ?arg
                            &   whl
                              ' ( !arg:(!wrd.?r2) ?arg
                                & !r2 !r1:?r1
                                )
                            & ( !arg:
                              | WHAT? !arg \n !ERROR:?ERROR
                              )
                            &   whl
                              ' (   !r1
                                  :   ?A
                                      (?L.?C1)
                                      ?M
                                      (!L.?C2)
                                      ?Z
                                & !A (!L.!C1+!C2) !M !Z:?r1
                                )
                            & denum$!r1:?r1
                            & (!wrd.!r1) !wlcs:?wlcs
                        )
                    & lst$(wlcs,!WLCfile,NEW)
                    & !wlcs
                  |     out
                      $ ( str
                        $ ("Cannot open " !WordLemmaPosData " for reading.")
                        )
                    & ~
              )
            & ( get$!WLCfile
              | createWLCfile$(!WordLemmaPosData.!plinepat):?wlcs
              )
            & new$hash:?H
            &   whl
              ' ( !wlcs:(?word.?LmCls:?AllLmCls) ?wlcs
                &   lemmatise$(!theTree.!word..0)
                  : ?results
                  : ?ress
                &   whl
                  ' ( !results:(?lm.?nrs) ?results
                    & !LmCls:?A (!lm.?cls) ?Z
                    & !A !Z:?LmCls
                    &   whl
                      ' ( !nrs:%?nr ?nrs
                        & (   (H..find)$!nr:(?nnr.?CLS)
                            & (H..remove)$!nr
                          | 0:?CLS
                          )
                        & (H..insert)$(!nr.!CLS+!cls)
                        )
                    )
                & ( !LmCls:!results:
                  |     (!word.!ress.!AllLmCls.!LmCls.!results)
                        !ERROR
                    : ?ERROR
                  )
                )
            & :?Index
            & (H..forall)$(=.!arg !Index:?Index)
            & lst$(Index,!IndexFile,NEW)
            & !H
        )
      & get$"lemmatize.bra"
      & str$(!TheFlexRules "Index.bra"):?IndexFile
      & str$(!TheFlexRules "WLC.bra"):?WLCfile
      & get$!TheFlexRules:?theTree
      & :?ERROR
      & (   get$!IndexFile
          & new$hash:?H
          &   whl
            ' (!Index:%?k ?Index&(H..insert)$!k)
        |   clk$:?t0
          &     createIndexFile
              $ (!WordLemmaPosData.!plinepat.!IndexFile.!WLCfile)
            : ?H
          & clk$:?t1
          & out$(T flt$(!t1+-1*!t0,4) s)
          & ( !ERROR:&(rmv$ERROR|)
            | lst$(ERROR,ERROR,NEW)
            )
        )
      & :?wlcs
      & get$!WLCfile
      & new$hash:?J
      & map$((=.(J..insert)$!arg).!wlcs)
      & ( asList
        =   g
          .   !arg:%?g+%?arg&!g " " asList$!arg
            | !arg
        )
      & ( getAnswer
        =   R RES wrd nrs CLS nr cls
          .   !arg:
            |   (     ( (J..find)$!arg
                      | (J..find)$(low$!arg)
                      )
                    : (?.?R)
                  & :?RES
                  &   whl
                    ' ( !R:(?lm.?cls) ?R
                      & !RES " | " !lm ":" asList$!cls:?RES
                      )
                  & !RES:" | " ?RES
                  & put$(str$("Dict=" !arg \t !RES \n))
                | 
                )
              & lemmatise$(!theTree.!arg..0):?R
              & ( low$!arg:?larg:!arg
                |   lemmatise$(!theTree.!larg..0):?R2
                  & !R:~!R2
                  & !R:? [?L1
                  & !R2:? [?L2
                  & ( !L2:>!L1
                    |   !L2:!L1
                      & ( countClasses
                        =   nrs CLS nr cls g
                          .     !arg:(?.?nrs) ?arg
                              & 0:?CLS
                              &   whl
                                ' ( !nrs:%?nr ?nrs
                                  & (H..find)$!nr:(?.?cls)
                                  & !CLS+!cls:?CLS
                                  )
                              & !CLS:?+[?g
                              & !g+countClasses$!arg
                            | 0
                        )
                      & countClasses$!R:?L1
                      & countClasses$!R2:?L2
                      & !L2:<!L1
                    )
                  & !R2:?R
                | 
                )
              & :?RES
              &   whl
                ' ( !R:(?wrd.?nrs) ?R
                  & 0:?CLS
                  &   whl
                    ' ( !nrs:%?nr ?nrs
                      & (H..find)$!nr:(?.?cls)
                      & !CLS+!cls:?CLS
                      )
                  & !RES " | " !wrd ":" asList$(denum$!CLS):?RES
                  )
              & !RES:" | " ?RES
              & put$(str$("Rule=" !arg \t !RES \n))
        )
      & (   get$(arg$2,STR,TXT):?txt
          &   vap
            $ ( ( 
                =   
                  .   vap
                    $ ((=.vap$(getAnswer.!arg." ")).!arg.\t)
                )
              . !txt
              . \n
              )
        |   out$"Type word and press ENTER. To stop, just press ENTER."
          &   whl
            ' (get':~:?word&getAnswer$!word)
          & BYE
          & done
        )
  )
  ( new
  =   
    .   (its.doit)
      $ ( !(its.Flexrules)
        . !(its.WordLemmaPosData-file-name)
        . '$(its.WordLemmaPosData-layout)
        )
  );

r=
  get'("LemmaX.bra",TXT)
& rmv$(str$(LemmaX ".bak"))
& ren$("LemmaX.bra".str$(LemmaX ".bak"))
&   put
  $ ( "{LemmaX.bra

For each input word, predict the possible lemma(s) and for each predicted lemma
predict also the classes (e.g. Part of Speech tags) that may apply.

The program first tests whether the input word is in the dictionary. If that is
the case, it presents the classes that are found in the dictionary.

If the word is not found in the dictionary, and if the word contains upper case
letters, then a new attempt is made with the lowercased version of the input
word.

If the word still is not found in the dictionary, then the rules are applied.
Again, special action is taken if the word contains uppercase letters:

If the rules generate more lemmas for the lowercased version of the input word
than for the original word, then the the result from lowercasing is used.

Conversely, if the rules generate more lemmas for the original version of the
input word than for the lowercased vesrion of the word, then the the result
for the original word is used.

The result from lowercasing is also used if the number of lemmas is the same
in both cases, but the total number of classes is less for the lowercased word.

So the rules are applied to maximise the number of lemmas, but to minimize the
total number of classes if the number of lemmas is the same for the original
and for the lowercased input word.

--- Input and Output

The input should be tokenised. Tokens may be separated by new lines and by
spaces.

The output is rather complex. For each word, all predicted lemmas are shown,
and for each lemma, all predicted classes. If an input word is found in the
dictionary, both the results according to the dictionary and those according
to the lemmatisation rules are shown.

Results from the dictionary are on a line that starts with Dict=
Results generated by rules are on a line that starts with Rule=

After the = follows the word, and then a tabulor character, followed by the
lemmas and their classes.

Each lemma is immediately followed by a : and then a list of classes, separated
by spaces. Between the last class of a lemma and the next lemma is a | 
surrounded by spaces.

--- Running

The program can be run in batch mode and interactively.

To run the program in batch mode, write

    bracmat get$\\\"Lemmax.bra\\\" <tokenised_input_file>

in Windows, and 

    bracmat \"get$\\\"Lemmax.bra\\\"\" <tokenised_input_file>

in Linux-like environments.

To run the program interactively, start bracmat without parameters:

    bracmat

Then, after the {?} prompt, write

    {?} get$\"LemmaX.bra\"

When the linguistic resources are loaded, the program says:

    Type word and press ENTER. To stop, just press ENTER.

Type words one by one. The program exits when you press ENTER on an empty line.
You can reload and re-run the program by typing

    !r

This command reads the progam and then runs and saves the program, so the last
changes you made to this file become nicely indented. In other words: if you
change the code, do not invest time in indention of the code. This is not
Python.

--- Resources

The program needs, apart from the input words, also lemmatization rules
(flexrules) and an index that assigns a set of classes to each lemmatization
rule.

If the index does not exist yet, it is built from a list of full form - lemma
data with additional class data for each full form - lemma pair. When building
this list, the program lemmatises each full form. That produces a list of one
or more lemmas. Then the program inspects the list to find the matching lemma.
(If a matching lemma is not found, then a message is added to the ERROR file.)
The ID of the rule that produced the matching lemma is paired with the class
data and remembered in the index. Finally the index is saved to a file.

This Bracmat script uses another Bracmat script, \"lemmatize.bra\", which must
be in the same location.

You need to install Bracmat (a programming language specialised in pattern
matching) to run this script. See

https://github.com/BartJongejan/Bracmat

===============================================================================
Comments about the code
-------------------------------------------------------------------------------
Flexrules: the path (relative or full) to the file that contains lemmatization
rules in Bracmat format. The rules should be trained WITHOUT using Part Of
Speech tags. You can create Bracmat-formatted rules as follows:

prompt> affixtrain -n FB00 -i MyTrainingdata
prompt> affixtrain -b 0/flexrules.MyTrainingdata_XC

The first command creates the flexrules in binary format, for use by CSTlemma.

The second command reads the binary flexrules and creates the files 
    0/flexrules.MyTrainingdata_XC.pretty.bra
and 
    0/flexrules.MyTrainingdata_XC.pretty.txt
You only need the first of these two files.
-------------------------------------------------------------------------------
WordLemmaPosData-file-name: the path (relative or full) to a TAB separated file
that has a column with words, a column with the lemmas of those words, and a
column with PoS tags. There may be more columns, but those will be ignored.
This can be the same file with which the flex rules were trained. (In which
case you only should have used the columns with words and with lemmas.)
-------------------------------------------------------------------------------
WordLemmaPosData-layout: This is a pattern that tells the program how a line in
the file described above is built up. The pattern must contain the pattern
variables ?word ?lemma and ?class. Write \\t for a tab, and write ? for matching
anything. A ? that is the last pattern component matches everything up to the
end of the line, also any tab characters. To skip a single column, write 
    ? \\t 	
Other separators than tabs can be used, e.g. semicolons, single spaces or
vertical bars. Write these characters between quotes, otherwise they are
interpreted in a way you do not want.
-------------------------------------------------------------------------------
}

"
    , "LemmaX.bra"
    , NEW
    , BIN
    )
& lst'(LemmaX,"LemmaX.bra",APP)
& put'(\n,"LemmaX.bra",APP,BIN)
& lst'(r,"LemmaX.bra",APP)
& put$(str$("\nnew'" LemmaX ";\n"),"LemmaX.bra",APP,BIN)
& ;

new'LemmaX;
